<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<columns>

<column id="grammar">
<Grammar>
<ident>Arithmetic</ident> {

<Rule><ident>Exp</ident>
  <Alt><op>=</op> <ident>AddExp</ident></Alt>
</Rule>

<Rule><ident>AddExp</ident>
  <Alt><op>=</op> <ident>AddExp</ident> <str>&ldquo;+&rdquo;</str> <ident>MulExp</ident>  <tag>-- plus</tag></Alt>
  <Alt><op>|</op> <ident>AddExp</ident> <str>&ldquo;-&rdquo;</str> <ident>MulExp</ident>  <tag>-- minus</tag></Alt>
  <Alt><op>|</op> <ident>MulExp</ident></Alt>
</Rule>

<Rule><ident>MulExp</ident>
  <alt><op>=</op> <ident>MulExp</ident> <str>&ldquo;*&rdquo;</str> <ident>ExpExp</ident>  <tag>-- times</tag></alt>
  <alt><op>|</op> <ident>MulExp</ident> <str>&ldquo;/&rdquo;</str> <ident>ExpExp</ident>  <tag>-- divide</tag></alt>
  <alt><op>|</op> <ident>ExpExp</ident></alt>
</Rule>

<Rule><ident>ExpExp</ident>
  <alt><op>=</op> <ident>PriExp</ident> <str>&ldquo;^&rdquo;</str> <ident>ExpExp</ident>  <tag>-- power</tag></alt>
  <alt><op>|</op> <ident>PriExp</ident></alt>
</Rule>

<Rule><ident>PriExp</ident>
  <alt><op>=</op> <str>&ldquo;(&rdquo;</str> <ident>Exp</ident> <str>&ldquo;)&rdquo;</str>  <tag>-- paren</tag></alt>
  <alt><op>|</op> <str>&ldquo;+&rdquo;</str> <ident>PriExp</ident>   <tag>-- pos</tag></alt>
  <alt><op>|</op> <str>&ldquo;-&rdquo;</str> <ident>PriExp</ident>   <tag>-- neg</tag></alt>
  <alt><op>|</op> <ident>ident</ident></alt>
  <alt><op>|</op> <ident>number</ident></alt>
</Rule>

<Comment>/*
  The following rules have *descriptions*, which are optional parenthesized "comments" following
  the name of a rule in its declaration. rule descriptions are used to produce better error
  messages when the input is not recognized. E.g., if you try to match the input "123" with the
  `ident` rule below, Ohm will say that "an identifier" was expected. Without `ident`'s rule
  description, the error message would have said that "a letter" was expected -- which is true,
  but probably too low-level to be helpful. Note that `letter`, `alnum`, and `digit` are built-in
  rules with their own descriptions (you can see their declarations in src/built-in-rules.ohm).
*/</Comment>

<Rule><ident>ident</ident>  <tag>(an identifier)</tag>
  <alt><op>=</op> <ident>letter</ident> <ident>alnum</ident><op>*</op></alt>
</Rule>

<Rule><ident>number</ident>  <tag>(a number)</tag>
  <alt><op>=</op> <ident>digit</ident><op>*</op> <str>&ldquo;.&rdquo;</str> <ident>digit</ident><op>+</op>  <tag>-- fract</tag></alt>
  <alt><op>|</op> <ident>digit</ident><op>+</op>             <tag>-- whole</tag></alt>
</Rule>

}
</Grammar>
</column>

<column id="semantics">
<semantics>
<name>interpret</name>

<action ruleId="Exp">e.interpret();</action>

<action ruleId="AddExp" class="last">e.interpret();</action>

<action ruleId="AddExp_plus">x.interpret() + y.interpret();</action>

<action ruleId="AddExp_minus">x.interpret() - y.interpret();</action>

<action ruleId="MulExp" class="last">e.interpret();</action>

<action ruleId="MulExp_times">x.interpret()
*
y.interpret();</action>

<action ruleId="MulExp_divide">x.interpret() / y.interpret();</action>

<action ruleId="ExpExp" class="last">e.interpret();</action>

<action ruleId="ExpExp_power">Math.pow(
  x.interpret(),
  y.interpret()
);</action>

<action ruleId="PriExp" class="last">e.interpret();</action>

<action ruleId="PriExp_paren">e.interpret();</action>

<action ruleId="PriExp_pos">e.interpret();</action>

<action ruleId="PriExp_neg">-e.interpret();</action>

<action ruleId="ident" class="last">constants[this.interval.contents] || 0;</action>
<action ruleId="number" class="last">parseFloat(this.interval.contents);</action>
</semantics>
</column>

</columns>

<script src="jquery-2.2.0.min.js"></script>
<script>

  "use strict";

  var highlightedColor = "hsl(0,0%,85%)";
  var lightHighlightedColor = "hsl(0,0%,97%)";
  var unHighlightedColor = "hsla(0,0%,100%, 0)";

  var identColor = "hsla(58, 100%, 80%, 1)"

  var ideal;


  $(document).ready(function(){
    var idents = $('rule > ident');
    var currentIdent = 0;

    $(idents[currentIdent]).css("background-color", identColor);

    $(document).keypress(function(){
      console.log("key pressed");
      $(idents[currentIdent++ % idents.length]).css("background-color", unHighlightedColor);
      $(idents[currentIdent % idents.length]).css("background-color", identColor);
    })

    $('rule > alt').mouseover(function(){
      $(this).css("background-color", highlightedColor);
      $(this).parent().css("background-color", lightHighlightedColor);
      getAction($(this)).css("background-color", highlightedColor);
    }).mouseout(function(){
      $(this).css("background-color", unHighlightedColor);
      $(this).parent().css("background-color", unHighlightedColor);
      getAction($(this)).css("background-color", unHighlightedColor);
    });

    $('rule > ident, rule > tag').mouseover(function(){
      $(this).parent().css("background-color", highlightedColor);
      getRuleActions($(this).parent()).css("background-color", highlightedColor);
    }).mouseout(function(){
      $(this).parent().css("background-color", unHighlightedColor);
      getRuleActions($(this).parent()).css("background-color", unHighlightedColor);
    })

    $('action').mouseover(function(){
      $(this).css("background-color", highlightedColor);

      getRule($(this)).css("background-color", lightHighlightedColor);

      var highlight = getAlts($(this));
      if(highlight.length === 0){
        highlight = getRule($(this));
      }
      highlight.css("background-color", highlightedColor);

      $(idents[currentIdent % idents.length]).css("background-color", unHighlightedColor);

      idents = getRule($(this)).find('alt > ident');
      currentIdent = 0;

      $(idents[currentIdent]).css("background-color", identColor);
      // resolveOverlap($('action'), this);
    }).mouseout(function(){
      $(this).css("background-color", unHighlightedColor)

      var highlight = getAlts($(this));
      if(highlight.length === 0){
        highlight = getRule($(this));
      }
      highlight.css("background-color", unHighlightedColor);
      getRule($(this)).css("background-color", unHighlightedColor);

      $(idents[currentIdent % idents.length]).css("background-color", unHighlightedColor);
      idents = $('rule > ident');
      currentIdent = 0;

      $(idents[currentIdent]).css("background-color", identColor);
      // resolveOverlap($('action'));
    });

    moveToIdeal($('action'));
    resolveOverlap($('action'));
  })

  function getRule(action){
    var ruleName = action.attr("ruleId").split("_")[0];
    return $('rule > ident').filter(function(){
      return $(this).text() === ruleName;
    }).parent();
  }


  function getAlts(action){
    var ruleId = action.attr("ruleId");
    ruleId = ruleId.split("_");

    var alts = getRule(action).children('alt'); //set of alts
    if(ruleId.length === 2){
      return alts.find('tag')
        .filter(function(){
          return $(this).text() === "-- "+ruleId[1];
        }).parent();
    } else if(ruleId.length === 1){
      return alts.filter(function(){
        return $(this).children('tag').length === 0;
      });

      // return cur;
    }
  }


  function getAction(alt){
    var ruleName = alt.parent().children('ident').text();
    var altName = alt.children('tag');
    altName = altName.length > 0?
      altName.text().substring(3):
      "";

    return $('action').filter(function(){
      return $(this).attr("ruleId") === ruleName+
        (altName !== "" ? "_": "")+
        altName;
    });
  }

  function getRuleActions(rule){
    var ruleName = rule.children('ident').text();

    return $('action').filter(function(){
      return $(this).attr("ruleId").split("_")[0] === ruleName;
    })
  }

  function moveToIdeal(actions){
    actions.each(function(){
      var thisPos = $(this).offset().top;

      var alts = getAlts($(this));
      var idealPos;
      if(alts.length > 0){
        idealPos = alts.offset();
      } else {
        idealPos = getRule($(this)).children('ident').offset();
      }
      idealPos = idealPos.top;

      var top = idealPos - thisPos;
      $(this).css("top", top.toString());
    });
  }

  function resolveOverlap(actions, preferredItem){

    var sortedActions = actions.sort(function(a, b){
      var ay = $(a).offset().top,
          by = $(b).offset().top;
      return compare(ay, by);
    });

    var weights;
    if(preferredItem){
      weights = Array.prototype.slice.call(
        sortedActions.map(function(){
          return this === preferredItem?
                 10:
                 1;
        })
      );
    } else {
      weights = Array.prototype.slice.call(
        sortedActions.map(function(){ return 1;})
      );
    }


    var ideal = Array.prototype.slice.call(
      sortedActions.map(function(){
        return $(this).offset().top;
      })
    );

    var height = Array.prototype.slice.call(
      sortedActions.map(function(){
        return $(this).outerHeight(true);
      })
    );

    var err = function(y, i){ //for now. should weight this
      return weights[i] * Math.abs(ideal[i] - y);
    };
    var errRest = function(y, i){
      return ideal.slice(i).reduce(function(p, _, i){
        return p + err(y, i);
      },0);
    };

    var maxY = Math.floor(ideal.slice(-1)[0] + 1000);
    var minY = -1000;

    var OPT = [];
    for(var y = minY; y <= maxY; y++){
      OPT[y-minY] = [];
    }

    //edge cases
    for(var y = minY; y <= maxY; y++){
      OPT[y-minY][sortedActions.length] = 0;
    }

    //memoize
    for(var i = sortedActions.length - 1; i >= 0; i--){
      for(var y = maxY; y >= minY; y--){
        if(y+height[i] > maxY){
          OPT[y-minY][i] = errRest(y, i);
          continue;
        }

        var placeHere = err(y, i)+OPT[y+height[i] - minY][i+1];
        var stepToNext = OPT[y+1 - minY][i];

        OPT[y-minY][i] = Math.min(
          placeHere,
          stepToNext
        );
      }
    }

    //find answer
    var positions = [];
    var i = 0,
        y = minY;
    while(positions.length < sortedActions.length && y <= maxY){
      // console.log(OPT[y-minY][i], OPT[y+height[i] - minY][i+1]);
      var placeHere = err(y, i)+OPT[y+height[i] - minY][i+1];
      if(y+height[i] <= maxY &&
         OPT[y-minY][i] === placeHere){//place
        positions.push(y);
        y += height[i];
        i++;
      } else {
        y++;
      }
    }

    //mutate state
    sortedActions.each(function(i){
      var delta = positions[i] - ideal[i];
      var top = parseInt($(this).css("top"), 10);

      // $(this).css("top", top + delta);
      $(this).stop().animate({
        top: "+="+delta.toString()
      }, 200);
    });
  }

  function compare(a, b){
    if(a > b){
      return 1;
    } else if(a < b){
      return -1;
    } else {
      return 0;
    }
  }


</script>

</body>
</html>
