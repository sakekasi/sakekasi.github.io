{"version":3,"sources":["webpack:///./src/oo/index.js","webpack:///./src/exampleRepresentation/interaction.js","webpack:///./src/exampleRepresentation/reify.js","webpack:///./src/exampleRepresentation/mapSemantics.js","webpack:///./src/exampleRepresentation/simplifyCST.js","webpack:///./src/exampleRepresentation/tree_visualization.js","webpack:///./src/exampleRepresentation/treeUtils.js","webpack:///./src/oo/toAST.js","webpack:///./src/oo/classes.js"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAsC;;AAEtC,qBAAoB;;AAEpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,EAAC;;AAED;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACrMA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA,eAAc,QAAQ;AACtB;;AAEA;AACA,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzHA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,oBAAmB,eAAe,oBAAoB,IAAI,uBAAuB;AACjF;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACxCA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAsB,qBAAqB;AAC3C;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,4BAA4B;AACtD;AACA;;AAEA;AACA;;AAEA,uBAAsB;AACtB,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;;;;;;ACnEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP;;AAEA;AACA,sBAAqB,YAAY,EAAE;AACnC,sBAAqB,YAAY,EAAE;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA2C;;AAE3C;AACA,gCAA+B;AAC/B;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,uCAAsC,UAAU,IAAI,UAAU;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,6CAA4C,IAAI,IAAI,IAAI;AACxD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;;AAEP;AACA;AACA,6CAA4C,UAAU,IAAI,UAAU;AACpE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAoC,gCAAgC,EAAE;AACtE,8BAA6B,gBAAgB,EAAE;AAC/C;AACA,qCAAoC,mCAAmC,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA4B,QAAQ;AACpC;AACA;;AAEA;AACA,6BAA4B,QAAQ;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;;;;;;AC7KA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;AAEA,mDAAkD,kBAAkB,EAAE;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;ACvBA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,SAAQ;;AAER;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,IAAG;AACH;;;;;;;AC7NA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA","file":"oo.bundle.js","sourcesContent":["require(\"../interaction.js\");\nrequire(\"../exampleRepresentation/interaction.js\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/oo/index.js\n ** module id = 0\n ** module chunks = 1\n **/","//maybe we want to do this using WebComponents\n'use strict';\n\nvar $ = require(\"jquery\");\nvar reify = require(\"./reify.js\"),\n    mapSemantics = require(\"./mapSemantics.js\"),\n    simplifyCST = require(\"./simplifyCST.js\"),\n    language = require (\"../language.js\"),\n    TreeViz = require(\"./tree_visualization.js\").TreeViz,\n    treeUtils = require(\"./treeUtils.js\"),\n\n    toAST = require(\"../oo/toAST.js\"); //TODO: make this language agnostic\n\nvar _ = function(x){ return Array.prototype.slice.call(x)};\n\nvar domToOhm, ohmToDom, nodeToSimplified, nodeToResults, treeVisualization;\n\ndocument.addEventListener(\"DOMContentLoaded\", function(event) {\n  let grammar = language.grammar,\n      semantics = language.semantics;\n\n  //register semantic actions\n  reify.registerReifyActions(semantics);\n  mapSemantics.registerMapSemantics(grammar, semantics);\n  simplifyCST.registerSimplifyAction(semantics);\n\n  toAST.registerToAST(semantics);\n\n  //get semantics match\n  let exampleNode = document.querySelector('pre#example');\n  let example = exampleNode.textContent;\n  let match;\n  let semmatch;\n  try {\n    match = grammar.match(example);\n    semmatch = semantics(match);\n  } catch (e) {\n    console.error(match.message);\n  }\n\n\n  //reify the CST to DOM\n  let reified = reify.reify(semantics, match);\n  let DOM = reified[0];\n  domToOhm = reified[1];\n  ohmToDom = reified[2];\n\n  exampleNode.textContent = \"\";\n  exampleNode.appendChild(DOM);\n\n  //generate simplified CST\n  nodeToSimplified = new Map();\n  let simplifiedCST = semmatch.simplifyCST(null, nodeToSimplified);\n  nodeToResults = mapSemantics.mapSemantics(semantics, \"toAST\", match);\n\n  for(let key of nodeToResults.keys()){\n    if(! (key.constructor.name === \"TerminalNode\")){\n      let domNode = ohmToDom.get(key);\n      let result = nodeToResults.get(key);\n\n      key.result = result;\n      ohmToDom.get(nodeToSimplified.get(key).cstNodes[0]).setAttribute(\"possibleCurrent\", \"true\");\n      domNode.setAttribute(\"result\", result instanceof Error? \"error\": \"success\");\n    }\n  }\n\n  //setup \"exploding\" behaviour\n  DOM.classList.add(\"current\");\n  nodeToSimplified.get(domToOhm.get(DOM)).current = true;\n\n  treeVisualization = new TreeViz(\n    document.querySelector(\"svg\"),\n    simplifiedCST,\n    ohmToDom,\n    {\n      splitNode,\n      joinNode,\n      highlightNode,\n      unHighlightNode\n    }\n  );\n\n  DOM.addEventListener(\"click\", memobind1(onClick, DOM));\n  DOM.addEventListener(\"mouseover\", memobind1(onMouseover, DOM));\n  DOM.addEventListener(\"mouseout\", memobind1(onMouseout, DOM));\n\n\n});\n\nlet memo = new Map();\nfunction memobind1(fn, arg){\n  if(memo.has(fn) && memo.get(fn).has(arg)){\n    return memo.get(fn).get(arg);\n  } else {\n    let bound = fn.bind(null, arg);\n    if( !memo.has(fn) ){\n      memo.set(fn, new Map());\n    }\n\n    memo.get(fn).set(arg, bound);\n    return bound;\n  }\n}\n\n//EVENT LISTENERS\nfunction onClick(currentNode, event){\n  let currentSimplified = nodeToSimplified.get(domToOhm.get(currentNode));\n  if(event.altKey){\n    currentSimplified = currentSimplified.parent || currentSimplified;\n    joinNode(currentSimplified);\n  } else {\n    splitNode(currentSimplified);\n  }\n  event.stopPropagation();\n}\n\nfunction onMouseover(currentNode, event){\n  let currentSimplified = nodeToSimplified.get(domToOhm.get(currentNode));\n  highlightNode(currentSimplified);\n}\n\nfunction onMouseout(currentNode, event){\n  let currentSimplified = nodeToSimplified.get(domToOhm.get(currentNode));\n  unHighlightNode(currentSimplified);\n}\n\nfunction makeCurrent(simplifiedCSTNode){\n  let domNode = ohmToDom.get(simplifiedCSTNode.cstNodes[0]);\n  domNode.classList.add(\"current\");\n\n  domNode.addEventListener(\"click\", memobind1(onClick, domNode));\n  domNode.addEventListener(\"mouseover\", memobind1(onMouseover, domNode));\n  domNode.addEventListener(\"mouseout\", memobind1(onMouseout, domNode));\n}\n\nfunction makeNonCurrent(simplifiedCSTNode){\n  let domNode = ohmToDom.get(simplifiedCSTNode.cstNodes[0]);\n  domNode.classList.remove(\"current\");\n\n  domNode.removeEventListener(\"click\", memobind1(onClick, domNode));\n  domNode.removeEventListener(\"mouseover\", memobind1(onMouseover, domNode));\n  domNode.removeEventListener(\"mouseout\", memobind1(onMouseout, domNode));\n\n  onMouseout(domNode);\n}\n\n\n//VISUALIZATION OPERATIONS\nfunction splitNode(simplifiedCSTNode){\n  let children = simplifiedCSTNode._children? simplifiedCSTNode._children: simplifiedCSTNode.children;\n\n  if(children && children.length > 0){\n    //make cst node's children current\n    simplifiedCSTNode.current = false;\n    makeNonCurrent(simplifiedCSTNode);\n\n    //make corresponding dom node's children current\n    children.forEach(child=> child.current = true);\n    children.forEach(makeCurrent);\n\n    //split tree visualization\n    treeVisualization.split(simplifiedCSTNode);\n  }\n}\n\nfunction joinNode(simplifiedCSTNode){\n  let descendants = treeUtils.descendants(simplifiedCSTNode, (child)=>\n    child._children? child._children: child.children);\n\n  //remove cst node's children's noncurrent\n  descendants.forEach(child=> child.current = false);\n  descendants.forEach(makeNonCurrent);\n\n  //make corresponding dom node current\n  simplifiedCSTNode.current = true;\n  makeCurrent(simplifiedCSTNode);\n\n  //join tree visualization\n  treeVisualization.join(simplifiedCSTNode);\n}\n\nfunction highlightNode(simplifiedCSTNode){\n  //highlight corresponding dom node\n  let domNode = ohmToDom.get(simplifiedCSTNode.cstNodes[0]);\n  domNode.classList.add(\"active\");\n\n  //highlight tree visualization\n  treeVisualization.highlight(simplifiedCSTNode);\n}\n\nfunction unHighlightNode(simplifiedCSTNode){\n  //unhighlight corresponding dom node\n  let domNode = ohmToDom.get(simplifiedCSTNode.cstNodes[0]);\n  domNode.classList.remove(\"active\");\n\n  //unhighlight tree viz\n  treeVisualization.unHighlight(simplifiedCSTNode);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/exampleRepresentation/interaction.js\n ** module id = 16\n ** module chunks = 1\n **/","'use strict';\n\nvar util = require(\"../util.js\");\n\nvar getWithInit = util.getWithInit,\n    mapObject = util.mapObject,\n    mergeObjects = util.mergeObjects;\n\nvar toExport = {\n  registerReifyActions,\n  reify\n};\n\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\"){\n  module.exports = toExport;\n} else {\n  Object.assign(window, toExport);\n}\n\nfunction closeTag(tagName){\n  return `</${tagName}>`;\n}\n\nfunction openTag(tagName){\n  return `<${tagName}>`;\n}\n\nfunction registerReifyActions(semantics){\n  semantics.addOperation(\"reifyAST(tagPositions)\", {\n    _nonterminal(children){\n      let start = this.interval.startIdx,\n      end = this.interval.endIdx;\n      let tagName = this._node.ctorName;\n\n      getWithInit(this.args.tagPositions, start, []).push(openTag(tagName));\n      children.forEach(child=> child.reifyAST(this.args.tagPositions));\n      getWithInit(this.args.tagPositions, end, []).push(closeTag(tagName));\n    }\n  });\n\n  semantics.addOperation(\"mapDOM(DOMNode, domToOhm, ohmToDom)\", {\n    _nonterminal(children){\n      this.args.domToOhm.set(this.args.DOMNode, this._node);\n      this.args.ohmToDom.set(this._node, this.args.DOMNode);\n\n      let DOMChildren = Array.prototype.slice.apply(this.args.DOMNode.children);\n      for(let i=0; i < children.length; i++){\n        let child = children[i];\n        if(child._node.ctorName === \"_iter\"\n        && !(child._node.children.length > 0\n          && child._node.children[0].constructor.name === \"TerminalNode\")){\n            let nodes = [];\n            child.children.forEach(()=> nodes.push(DOMChildren.shift()));\n\n            child.mapDOM(nodes, this.args.domToOhm, this.args.ohmToDom);\n            // i += child.children.length === 0? 0: child.children.length - 1;\n          } else if(child._node.constructor.name !== \"TerminalNode\"\n          && child._node.ctorName !== \"_iter\"){\n            child.mapDOM(DOMChildren.shift(), this.args.domToOhm, this.args.ohmToDom);\n          }\n        }\n      },\n      _iter(children){\n        let DOMNodes = this.args.DOMNode;\n        if(children.length !== DOMNodes.length){\n          return;\n        }\n\n        children.forEach((child, i)=> child.mapDOM(DOMNodes[i], this.args.domToOhm, this.args.ohmToDom));\n      }\n    });\n}\n\nfunction reify(semantics, match){\n  let tagPositions = {};\n  let domToOhm = new Map(),\n      ohmToDom = new Map();\n  let example = match._cst.interval.contents;\n\n  let semmatch = semantics(match);\n\n  semmatch.reifyAST(tagPositions);\n\n  tagPositions = mapObject(tagPositions, function(tags){\n    return tags.join(\"\");\n  });\n\n  var positionsToInsert = Object.keys(tagPositions);\n  var stringsToInsert = Object.keys(tagPositions).map((key)=>tagPositions[key]);\n\n  var start = 0,\n      end;\n  var splitExampleString = [];\n  while(positionsToInsert.length > 0){\n    end = positionsToInsert.shift();\n    splitExampleString.push(\n      example.substring(start, end)\n    );\n\n    start = end;\n  }\n  splitExampleString.push(\n    example.substring(start)\n  );\n\n  var annotatedExamplePieces = [];\n  annotatedExamplePieces.push(splitExampleString.shift());\n  while(stringsToInsert.length > 0){\n    annotatedExamplePieces.push(stringsToInsert.shift());\n    annotatedExamplePieces.push(splitExampleString.shift());\n  }\n  annotatedExamplePieces.push(splitExampleString.shift());\n\n  let annotatedExample = annotatedExamplePieces.join(\"\");\n  let parser = new DOMParser();\n  let DOM = parser.parseFromString(annotatedExample, \"text/html\");\n  DOM = DOM.querySelector('body').children[0];\n\n  semmatch.mapDOM(DOM, domToOhm, ohmToDom);\n\n  return [DOM, domToOhm, ohmToDom];\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/exampleRepresentation/reify.js\n ** module id = 17\n ** module chunks = 1\n **/","'use strict';\n\nvar toExport = {\n  registerMapSemantics,\n  mapSemantics\n};\n\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\"){\n  module.exports = toExport;\n} else {\n  Object.assign(window, toExport);\n}\n\nfunction registerMapSemantics(grammar, semantics){\n  semantics.addOperation(\"mapSemantics(action, nodeToResults)\", {\n    _nonterminal(children){\n      let examplePiece = this.interval.contents;\n\n      let result;\n      try {\n        let match = grammar.match(examplePiece, this._node.ctorName);\n        result = semantics(match)[this.args.action]();\n      } catch(e) {\n        // console.error(e);\n        result = e;//new Error(`${this._node.ctorName}: ${this.interval.contents}`);\n      }\n\n      this.args.nodeToResults.set(this._node, result);\n\n      children.forEach(child=> child.mapSemantics(this.args.action, this.args.nodeToResults));\n    }\n  });\n}\n\nfunction mapSemantics(semantics, action, match){\n  let nodeToResults = new Map();\n\n  semantics(match).mapSemantics(action, nodeToResults);\n\n  return nodeToResults;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/exampleRepresentation/mapSemantics.js\n ** module id = 18\n ** module chunks = 1\n **/","'use strict';\n\nvar toExport = {\n  registerSimplifyAction\n};\n\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\"){\n  module.exports = toExport;\n} else {\n  Object.assign(window, toExport);\n}\n\nfunction registerSimplifyAction(semantics){\n  semantics.addOperation(\"simplifyCST(simplifiedParentNode, nodeToSimplified)\", {\n    _nonterminal(children){\n      let simplifiedNode;\n      if(this.args.simplifiedParentNode\n        && this.args.simplifiedParentNode.cstNodes[0].interval.contents ===\n        this.interval.contents){\n          simplifiedNode = this.args.simplifiedParentNode;\n          simplifiedNode.cstNodes.push(this._node);\n          simplifiedNode.ctorName = this._node.ctorName;\n\n        } else {\n          simplifiedNode = {\n            ctorName: this._node.ctorName,\n            cstNodes: [this._node],\n            parent: this.args.simplifiedParentNode,\n            children: []\n          };\n\n          if(this.args.simplifiedParentNode){\n            this.args.simplifiedParentNode.children.push(simplifiedNode);\n          }\n        }\n\n        this.args.nodeToSimplified.set(this._node, simplifiedNode);\n\n        for(let i = 0; i < children.length; i++){\n          let child = children[i];\n          if(child.constructor.name === \"IterationNode\"){ //makes iterations children of current node\n            //collect iterations for same interval\n            let run = [child];\n            let j = i + 1;\n            while(children[j].interval.contents === child.interval.contents){\n              run.push(children[j]);\n              j++;\n            }\n\n            let runLength = run.length,\n            iterLength = run[0].length;\n            for(let k = 0; k < runLength * iterLength; k++){\n              let iterIdx = k % runLength;\n              let childIdx = Math.floor(k / iterLength);\n\n              run[iterIdx].children[childIdx].simplifyCST(simplifiedNode, this.args.nodeToSimplified);\n            }\n\n            i = j - 1; //so that i++ = j\n          } else {\n            child.simplifyCST(simplifiedNode, this.args.nodeToSimplified);\n          }\n        }\n\n        return simplifiedNode;\n      }\n    });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/exampleRepresentation/simplifyCST.js\n ** module id = 19\n ** module chunks = 1\n **/","'use strict';\n\nvar treeUtils = require(\"./treeUtils.js\");\n\nvar duration = 100;\nvar curId = 0;\n\nclass TreeViz{\n  constructor(svg, root, ohmToDom, actions){\n    this.ohmToDom = ohmToDom;\n    this.actions = actions;\n\n    this.svg = d3.select(svg)\n               .append(\"g\")\n                 .attr(\"transform\", \"translate(10, 10)\");\n\n    let boundingRect = svg.getBoundingClientRect();\n    this.width = boundingRect.width - 20;\n    this.height = boundingRect.height - 20;\n\n    this.tree = d3.layout.tree()\n      .children(function(n){\n        if(n.children && !n.hasOwnProperty('_children')){\n          n._children = n.children;\n        }\n\n        if(n._children\n           && n._children.length > 0){\n          let descendants = treeUtils.descendants(n, function(child){\n            if(child.children && !child._children){\n              child._children = child.children;\n            }\n\n            return child._children;\n          });\n\n          if(descendants.reduce((a,b)=> b.current || a, false)){\n            return n._children;\n          }\n        }\n\n        return null;\n      })\n      .size([this.height, this.width]);\n\n    this.voronoi = d3.geom.voronoi()\n    \t.x(function(d) { return d.y; })\n    \t.y(function(d) { return d.x; })\n    \t.clipExtent([[-10, -10], [this.width, this.height]]);\n\n    this.root = root;\n    this.root.x0 = this.height/2;\n    this.root.y0 = 0;\n\n    this.update(root);\n  }\n\n  update(parent){\n    let nodes = this.tree.nodes(this.root);//.reverse();\n\n    let svgNode = this.svg.selectAll(\"g.node\")\n      .data(nodes, function(d){ //assign each object an id since d3 can't do object equality apparently :/\n        if(d.id){\n          return d.id;\n        } else {\n          d.id = curId++;\n          return d.id;\n        }\n      });\n\n    let svgNodeEnter = svgNode.enter().append(\"g\")\n      .attr(\"class\", \"node\")\n      .attr(\"transform\", `translate(${parent.y0}, ${parent.x0})`)\n      .attr(\"id\", (d)=>d.id)\n    .append(\"circle\")\n      .attr(\"r\", 5);\n\n    let treeviz = this;\n    let svgNodeUpdate = svgNode\n      .on(\"mouseover\", function(datum){\n        treeviz.actions.highlightNode(datum);\n      }, true)\n      .on(\"mouseout\",  function(datum){\n        treeviz.actions.unHighlightNode(datum);\n      }, true)\n      .on(\"click\", function(datum){\n        if(d3.event.altKey){\n          treeviz.actions.joinNode(datum);\n        } else if(datum.current){\n          treeviz.actions.splitNode(datum);\n        }\n      }, true)\n    .transition().duration(duration)\n      .attr(\"transform\", (n)=> `translate(${n.y}, ${n.x})`)\n      .style(\"fill\", (n)=> {\n        if( n.cstNodes[0].result instanceof Error ){\n          return  \"red\";\n        } else {\n          return \"green\";\n        }\n      });\n\n    let svgNodeExit = svgNode.exit().transition()\n      .duration(duration)\n      .attr(\"transform\", (n)=> `translate(${parent.y0}, ${parent.x0})`)\n      .remove();\n\n    let polygon = function(d) {\n      return \"M\" + d.join(\"L\") + \"Z\";\n    };\n\n    //Create the Voronoi grid\n    let paths = this.svg.selectAll(\"path\")\n      .data(this.voronoi(nodes));\n\n    paths.enter().append(\"path\");\n    paths.exit().remove();\n\n    paths.attr(\"d\", function(d, i) { return \"M\" + d.join(\"L\") + \"Z\"; })\n      .datum(function(d, i) { return d.point; })\n            //Give each cell a unique class where the unique part corresponds to the circle classes\n      .attr(\"class\", function(d,i) { return \"voronoi \" + d.CountryCode; })\n      // .style(\"stroke\", \"#2074A0\") //If you want to look at the cells\n      .style(\"fill\", \"none\")\n      .style(\"pointer-events\", \"all\")\n      .on(\"mouseover\", function(datum){\n        treeviz.actions.highlightNode(datum);\n      })\n      .on(\"mouseout\",  function(datum){\n        treeviz.actions.unHighlightNode(datum);\n      })\n      .on(\"click\", function(datum){\n        if(d3.event.altKey){\n          treeviz.actions.joinNode(datum);\n        } else if(datum.current){\n          treeviz.actions.splitNode(datum);\n        }\n      }, true);\n\n    nodes.forEach((n)=>{\n      n.x0 = n.x;\n      n.y0 = n.y;\n    });\n  }\n\n  split(node){\n    // node.clicked = true;\n    this.update(node);\n  }\n\n  join(node){\n    this.update(node);\n  }\n\n  highlight(node){\n    d3.select(`g.node[id=\"${node.id}\"]`).selectAll(\"circle\").transition().duration(duration)\n      .attr(\"r\", 8);\n  }\n\n  unHighlight(node){\n    d3.select(`g.node[id=\"${node.id}\"]`).selectAll(\"circle\").transition().duration(duration)\n      .attr(\"r\", 5);\n  }\n}\n\nvar toExport = {\n  TreeViz\n};\n\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\"){\n  module.exports = toExport;\n} else {\n  Object.assign(window, toExport);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/exampleRepresentation/tree_visualization.js\n ** module id = 20\n ** module chunks = 1\n **/","'use strict';\n\nvar toExport = {\n  descendants\n};\n\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\"){\n  module.exports = toExport;\n} else {\n  Object.assign(window, toExport);\n}\n\nfunction descendants(node, children = function(n){return n.children; }){\n  let childrenQueue = Array.prototype.slice.call(children(node));\n  let descendants = [];\n  while(childrenQueue.length > 0){\n    let child = childrenQueue.shift();\n\n    descendants.push(child);\n    childrenQueue = childrenQueue.concat(children(child));\n  }\n\n  return descendants;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/exampleRepresentation/treeUtils.js\n ** module id = 21\n ** module chunks = 1\n **/","'use strict';\n\nvar classes = require(\"./classes.js\");\n\nvar toExport = {\n  registerToAST\n};\n\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\"){\n  module.exports = toExport;\n} else {\n  Object.assign(window, toExport);\n}\n\nfunction registerToAST(semantics){\n  semantics.addOperation('toAST', {\n    Program: function(stmts) {\n      return new classes.Program(stmts.toAST());\n    },\n\n    Stmts: function(ss, optE) {\n      var e = optE.toAST()[0];\n      return ss.toAST().concat(e ? new classes.ExpStmt(e) : []);\n    },\n\n    Stmt_classDecl: function(_class, C, _optExtends, optS, _optWith, optXs, _sc) {\n      return new classes.ClassDecl(\n        C.toAST(),\n        optS.toAST()[0] || 'Obj',\n        optXs.toAST()[0] || []);\n    },\n\n    Stmt_methodDeclJava: function(_def, C, _dot, m, _op, xs, _cp, b) {\n      return new classes.MethodDecl(\n        C.toAST(),\n        m.toAST(),\n        xs.toAST(),\n        b.toAST());\n    },\n\n    Stmt_methodDeclKeyword: function(_def, C, ms, _commas, xs, b) {\n      return new classes.MethodDecl(\n        C.toAST(),\n        ms.toAST().reduce((m, part) => m + part.charAt(0).toUpperCase() + part.substr(1)),\n        xs.toAST(),\n        b.toAST());\n    },\n\n    Stmt_methodDeclBinary: function(_def, C, m, x, b) {\n      return new classes.MethodDecl(\n        C.toAST(),\n        m.toAST(),\n        [x.toAST()],\n        b.toAST());\n    },\n\n    Stmt_methodDeclCall: function(_def, C, _op, xs, _cp, b) {\n      return new classes.MethodDecl(\n        C.toAST(),\n        'call',\n        xs.toAST(),\n        b.toAST());\n    },\n\n    Stmt_varDecl: function(_var, x, _eq, e, _sc) {\n      return new classes.VarDecl(x.toAST(), e.toAST());\n    },\n\n    Stmt_varAssign: function(x, _eq, e, _sc) {\n      return new classes.VarAssign(x.toAST(), e.toAST());\n    },\n\n    Stmt_instVarAssign: function(_this, _dot, x, _eq, e, _sc) {\n      return new classes.InstVarAssign(x.toAST(), e.toAST());\n    },\n\n    Stmt_return: function(_return, e, _sc) {\n      return new classes.Return(e.toAST());\n    },\n\n    Stmt_exp: function(e, _sc) {\n      return new classes.ExpStmt(e.toAST());\n    },\n\n    MethodBody_exp: function(_eq, e, _sc) {\n      return [new classes.Return(e.toAST())];\n    },\n\n    MethodBody_stmt: function(_oc, ss, _cc) {\n      return ss.toAST();\n    },\n\n    KWSendExp_send: function(e, ms, _colons, es) {\n      return new classes.Send(\n        e.toAST(),\n        ms.toAST().reduce((m, part) => m + part.charAt(0).toUpperCase() + part.substr(1)),\n        es.toAST());\n    },\n\n    KWSendExp_super: function(_this, ms, _colons, es) {\n      return new classes.SuperSend(\n        ms.toAST().reduce((m, part) => m + part.charAt(0).toUpperCase() + part.substr(1)),\n        es.toAST());\n    },\n\n    EqExp_eq: function(x, op, y) {\n      return new classes.BinOp(op.toAST(), x.toAST(), y.toAST());\n    },\n\n    RelExp_rel: function(x, op, y) {\n      return new classes.BinOp(op.toAST(), x.toAST(), y.toAST());\n    },\n\n    AddExp_add: function(x, op, y) {\n      return new classes.BinOp(op.toAST(), x.toAST(), y.toAST());\n    },\n\n    MulExp_mul: function(x, op, y) {\n      return new classes.BinOp(op.toAST(), x.toAST(), y.toAST());\n    },\n\n    DotExp_send: function(e, _dot, m, _op, es, _cp) {\n      return new classes.Send(e.toAST(), m.toAST(), es.toAST());\n    },\n\n    DotExp_super: function(_super, _dot, m, _op, es, _cp) {\n      return new classes.SuperSend(m.toAST(), es.toAST());\n    },\n\n    // DotExp_instVarAccess: function(_this, _dot, x) {\n    //   return new classes.InstVar(x.toAST());\n    // },\n\n    UnExp_neg: function(_minus, x) {\n      return new classes.BinOp('-', new classes.Lit(0), x.toAST());\n    },\n\n    CallExp_call: function(b, _op, es, _cp) {\n      return new classes.Send(b.toAST(), 'call', es.toAST());\n    },\n\n    PriExp_paren: function(_op, e, _cp) {\n      return e.toAST();\n    },\n\n    PriExp_block: function(_oc, xs, ss, _cc) {\n      return new classes.BlockLit(xs.toAST(), ss.toAST());\n    },\n\n    PriExp_new: function(_new, C, _op, es, _cp) {\n      return new classes.New(C.toAST(), es.toAST());\n    },\n\n    PriExp_str: function(s) {\n      return new classes.Lit(s.toAST());\n    },\n\n    PriExp_ident: function(n) {\n      return new classes.Var(n.toAST());\n    },\n\n    PriExp_number: function(_) {\n      return new classes.Lit(parseFloat(this.interval.contents));\n    },\n\n    PriExp_this: function(_) {\n      return new classes.This();\n    },\n\n    PriExp_true: function(_) {\n      return new classes.Lit(true);\n    },\n\n    PriExp_false: function(_) {\n      return new classes.Lit(false);\n    },\n\n    PriExp_null: function(_) {\n      return new classes.Lit(null);\n    },\n\n    BlockArgNames_some: function(xs, _bar) {\n      return xs.toAST();\n    },\n\n    BlockArgNames_none: function() {\n      return [];\n    },\n\n    ident: function(_first, _rest) {\n      return this.interval.contents;\n    },\n\n    string: function(_oq, cs, _cq) {\n      var chars = [];\n      var idx = 0;\n      cs = cs.toAST();\n      while (idx < cs.length) {\n        var c = cs[idx++];\n        if (c === '\\\\' && idx < cs.length) {\n          c = cs[idx++];\n          switch (c) {\n            case 'n': c = '\\n'; break;\n            case 't': c = '\\t'; break;\n            default: idx--;\n          }\n        }\n        chars.push(c);\n      }\n      return chars.join('');\n    },\n\n    NonemptyListOf: function(x, _seps, xs) {\n      return [x.toAST()].concat(xs.toAST());\n    },\n\n    EmptyListOf: function() {\n      return [];\n    }\n\n  });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/oo/toAST.js\n ** module id = 22\n ** module chunks = 1\n **/","'use strict';\n\n\n// ---------------------------------------------------------\n// \"Classes\" that represent AST nodes\n// ---------------------------------------------------------\n\nclass AST {}\n\nclass Program extends AST {\n  constructor(ss) {\n    super();\n    this.ss = ss;\n  }\n}\n\n// Statements\n\nclass Stmt extends AST {\n  constructor() {\n    super();\n  }\n}\n\nclass ClassDecl extends Stmt {\n  constructor(C, S, xs) {\n    super();\n    this.C = C;\n    this.S = S;\n    this.xs = xs;\n  }\n}\n\nclass MethodDecl extends Stmt {\n  constructor(C, m, xs, ss) {\n    super();\n    this.C = C;\n    this.m = m;\n    this.xs = xs;\n    this.ss = ss;\n  }\n}\n\nclass VarDecl extends Stmt {\n  constructor(x, e) {\n    super();\n    this.x = x;\n    this.e = e;\n  }\n}\n\nclass VarAssign extends Stmt {\n  constructor(x, e) {\n    super();\n    this.x = x;\n    this.e = e;\n  }\n}\n\nclass InstVarAssign extends Stmt {\n  constructor(x, e) {\n    super();\n    this.x = x;\n    this.e = e;\n  }\n}\n\nclass Return extends Stmt {\n  constructor(e) {\n    super();\n    this.e = e;\n  }\n}\n\nclass ExpStmt extends Stmt {\n  constructor(e) {\n    super();\n    this.e = e;\n  }\n}\n\n// Expressions\n\nclass Exp extends AST {\n  constructor() {\n    super();\n  }\n}\n\nclass Lit extends Exp {\n  constructor(primValue) {\n    super();\n    this.primValue = primValue;\n  }\n}\n\nclass Var extends Exp {\n  constructor(x) {\n    super();\n    this.x = x;\n  }\n}\n\nclass BinOp extends Exp {\n  constructor(op, e1, e2) {\n    super();\n    this.op = op;\n    this.e1 = e1;\n    this.e2 = e2;\n  }\n}\n\nclass This extends Exp {\n  constructor() {\n    super();\n  }\n}\n\nclass InstVar extends Exp {\n  constructor(x) {\n    super();\n    this.x = x;\n  }\n}\n\nclass New extends Exp {\n  constructor(C, es) {\n    super();\n    this.C = C;\n    this.es = es;\n  }\n}\n\nclass Send extends Exp {\n  constructor(erecv, m, es) {\n    super();\n    this.erecv = erecv;\n    this.m = m;\n    this.es = es;\n  }\n}\n\nclass SuperSend extends Exp {\n  constructor(m, es) {\n    super();\n    this.m = m;\n    this.es = es;\n  }\n}\n\nclass BlockLit extends AST {\n  constructor(xs, ss) {\n    super();\n    this.xs = xs;\n    this.ss = ss;\n  }\n}\n\nvar toExport = {\n  AST,\n  Program,\n  Stmt,\n  ClassDecl,\n  MethodDecl,\n  VarDecl,\n  VarAssign,\n  InstVarAssign,\n  Return,\n  ExpStmt,\n  Exp,\n  Lit,\n  Var,\n  BinOp,\n  This,\n  InstVar,\n  New,\n  Send,\n  SuperSend,\n  BlockLit\n};\n\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\"){\n  module.exports = toExport;\n} else {\n  Object.assign(window, toExport);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/oo/classes.js\n ** module id = 23\n ** module chunks = 1\n **/"],"sourceRoot":""}